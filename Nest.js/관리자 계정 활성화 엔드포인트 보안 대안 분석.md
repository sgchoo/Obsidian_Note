[[Nest.js]]
# 문제 상황

관리자 계정의 상태를 비활성화에서 활성화로 변경하는 엔드포인트에 대한 보안 문제가 있습니다.

```typescript
@Patch("status/active/:adminId")
async updateAdminStatus(
  @Param("adminId") adminId: string,
): Promise<ResponseUpdateAdminDto> {
  try {
    const updateStatus: UpdateAdminStatusDto = {
      adminId,
      status: 1,
    };

    const adminInfo = await this.adminService.updateAdminStatus(updateStatus);

    return adminInfo;
  } catch (error: unknown) {
    this.logger.error(error as string, {
      context: "AdminController - updateAdminStatus",
    });

    throw error;
  }
}
```

- 위 엔드포인트는 현재 보안 검증 없이 접근 가능
- 관리자 회원가입 시 활성화 메일이 발송되고, 해당 메일의 링크를 통해 위 엔드포인트 호출 의도
- 문제점: Super 등급의 관리자만 접근할 수 있도록 제한이 필요함

## 대안 및 구현 방법

### 1. 역할 기반 가드를 이용한 보안 강화

```typescript
@Patch("status/active/:adminId")
@Roles(AdminRole.SUPER)
@UseGuards(AdminRoleGuard)
@UseGuards(JwtAuthGuard)
async updateAdminStatus(
  @Auth() auth: JwtPayload,
  @Param("adminId") adminId: string,
): Promise<ResponseUpdateAdminDto> {
  // 구현부
}
```

**장점**:

- 기존 인증 시스템 활용
- 명확한 역할 기반 접근 제어

**단점**:

- 이메일 링크로는 직접 접근 불가(이메일에 헤더 추가 불가)
- 기존 활성화 흐름 변경 필요

### 2. GET 엔드포인트로 변경 및 토큰 검증

```typescript
@Get("status/activate/:adminId")
async activateAdmin(
  @Param("adminId") adminId: string,
  @Query('token') token: string,
): Promise<any> {
  try {
    // 토큰 검증
    const isValidToken = await this.adminService.verifyActivationToken(token, adminId);
    if (!isValidToken) {
      throw new UnauthorizedException('유효하지 않은 활성화 토큰입니다.');
    }

    const updateStatus: UpdateAdminStatusDto = {
      adminId,
      status: 1,
    };

    // 계정 활성화 처리
    await this.adminService.updateAdminStatus(updateStatus);

    // 성공 페이지로 리다이렉트 또는 성공 메시지 반환
    return { message: '관리자 계정이 성공적으로 활성화되었습니다.' };
  } catch (error) {
    this.logger.error(error as string, {
      context: "AdminController - activateAdmin",
    });
    throw error;
  }
}
```

**장점**:

- 이메일 링크로 직접 접근 가능
- 사용자 경험 개선(리다이렉트 활용)

**단점**:

- 토큰 저장 및 관리 필요
- SUPER 관리자 검증이 토큰에 의존

### 3. 서명된 URL 방식

```typescript
// 메일 발송 시 서명된 URL 생성
const payload = { adminId: newAdmin.id, exp: Date.now() + 24*60*60*1000 };
const signedData = jwt.sign(payload, YOUR_SECRET_KEY);
const activationUrl = `https://yoursite.com/admin/activate?data=${signedData}`;

// 활성화 엔드포인트
@Get("activate")
async activateAdmin(@Query('data') signedData: string): Promise<any> {
  try {
    // 서명 검증
    const payload = jwt.verify(signedData, YOUR_SECRET_KEY);
    
    // 만료 확인
    if (payload.exp < Date.now()) {
      throw new Error('링크가 만료되었습니다');
    }
    
    // 계정 활성화
    await this.adminService.updateAdminStatus({
      adminId: payload.adminId,
      status: 1
    });
    
    // 성공 페이지로 리다이렉트
    return { redirect: '/activation-success' };
  } catch (error) {
    return { redirect: '/activation-failed' };
  }
}
```

**장점**:

- DB에 토큰 저장 불필요
- 만료 시간 설정 가능
- 데이터 무결성 보장

**단점**:

- SUPER 관리자 권한 확인 별도 필요
- URL이 탈취되면 활성화 가능

### 4. 클라이언트 측 활성화 페이지 구현

```typescript
// 클라이언트 측에서 처리 후 API 호출
@Patch("activate-admin")
@Roles(AdminRole.SUPER)
@UseGuards(AdminRoleGuard)
@UseGuards(JwtAuthGuard)
async activateAdmin(
  @Body() data: { adminId: string, verificationCode: string },
  @Auth() auth: JwtPayload
): Promise<ResponseUpdateAdminDto> {
  try {
    // verificationCode 검증
    const isValid = await this.adminService.verifyActivationCode(
      data.adminId, 
      data.verificationCode
    );
    
    if (!isValid) {
      throw new UnauthorizedException('유효하지 않은 인증 코드입니다.');
    }
    
    // 계정 활성화
    const adminInfo = await this.adminService.updateAdminStatus({
      adminId: data.adminId,
      status: 1
    });
    
    return adminInfo;
  } catch (error) {
    this.logger.error(error as string, {
      context: "AdminController - activateAdmin",
    });
    throw error;
  }
}
```

**장점**:

- 기존 인증/권한 시스템 활용 가능
- SUPER 관리자 권한 확실히 보장
- 사용자 경험 유지(로그인 안 되어 있으면 로그인 유도)

**단점**:

- 클라이언트 측 구현 필요
- 사용자 상호작용 추가 필요

## 다른 기업들의 관리자 활성화 적용 방법

### 1. 중앙 관리 시스템 접근 방식

- **GitHub, Atlassian**: 조직 관리자가 초대장 발송 후 신규 관리자 승인
- 장점: 강력한 보안, 명확한 권한 체계
- 단점: 활성화 과정이 다소 복잡할 수 있음

### 2. 토큰 기반 이메일 링크 방식

- **Slack, Discord**: 회원가입 후 이메일에 포함된 토큰 링크로 계정 활성화
- 장점: 간단한 사용자 경험
- 단점: 링크 탈취 위험

### 3. 이메일 링크 + 추가 인증 방식

- **AWS, Google Cloud**: 관리자 초대 링크 클릭 후 로그인 필요, 권한 확인 후 활성화
- 장점: 보안과 사용성 균형
- 단점: 다단계 인증 과정 필요

### 4. 관리자 승인 대시보드 방식

- **Salesforce, ServiceNow**: 관리자 승인 대기 목록에서 SUPER 관리자가 직접 승인
- 장점: 높은 보안성, 승인 과정 추적 용이
- 단점: 승인 대기 시간 발생 가능

## 권장 구현 방식

상황과 시스템 구조를 고려할 때, **클라이언트 측 활성화 페이지 구현** 방식이 가장 적합합니다:

1. 이메일에 활성화 링크 포함: `https://yoursite.com/admin/verify-account?adminId=123&verificationCode=xyz789`
    
2. 사용자가 링크 클릭 시 해당 페이지로 이동:
    
    - 로그인 여부 및 SUPER 권한 확인
    - 로그인 안 된 경우 로그인 페이지로 리다이렉트(파라미터 유지)
    - 권한 부족 시 적절한 메시지 표시
3. 관리자 활성화 API 호출:
    
    - SUPER 관리자 권한으로 API 호출
    - verificationCode 검증 후 계정 활성화

이 방식은 기존 인증 시스템을 활용하면서도 충분한 보안을 제공하며, 사용자 경험도 해치지 않습니다.