[[Nest.js]]

# N+1 문제와 해결 방법

## N+1 문제란?

N+1 문제는 데이터베이스 쿼리 수행 시 발생하는 성능 문제로, 관계형 데이터베이스에서 ORM(Object-Relational Mapping)을 사용할 때 특히 자주 발생합니다. 이 문제는 다음과 같은 패턴으로 나타납니다:

1. 부모 엔티티 목록을 가져오는 **1개의 쿼리**를 실행
2. 각 부모 엔티티와 연관된 자식 엔티티를 가져오기 위해 **N개의 추가 쿼리**를 실행

따라서 총 **N+1개의 쿼리**가 데이터베이스에 전송됩니다. 이는 불필요한 데이터베이스 연결과 쿼리를 발생시켜 애플리케이션의 성능을 크게 저하시킵니다.

## 예시 시나리오

게시판 시스템을 예로 들어보겠습니다:

1. 10개의 게시글을 조회하는 쿼리 1개 실행
2. 각 게시글에 대한 댓글을 가져오기 위해 10개의 추가 쿼리 실행

### 문제가 있는 코드 예시 (TypeScript/NestJS)

```typescript
// 컨트롤러
@Get('boards')
async getBoards() {
  const boards = await this.boardRepository.findAll();
  
  // N+1 문제 발생 지점
  for (const board of boards) {
    board.replies = await this.replyRepository.findByBoardId(board.id);
  }
  
  return boards;
}
```

### 실제 실행되는 SQL 쿼리

```sql
-- 게시글 목록 조회 (1번의 쿼리)
SELECT * FROM board LIMIT 10;

-- 각 게시글의 댓글 조회 (N번의 쿼리)
SELECT * FROM reply WHERE board_id = 1;
SELECT * FROM reply WHERE board_id = 2;
SELECT * FROM reply WHERE board_id = 3;
...
SELECT * FROM reply WHERE board_id = 10;
```

## N+1 문제가 미치는 영향

1. **데이터베이스 부하 증가**: 다수의 쿼리가 데이터베이스 서버에 부담을 줍니다.
2. **네트워크 오버헤드**: 각 쿼리마다 데이터베이스와의 통신이 필요합니다.
3. **응답 시간 증가**: 다수의 쿼리 실행으로 API 응답 시간이 길어집니다.
4. **확장성 저하**: 데이터가 증가할수록 성능 문제가 더 심각해집니다.

## 해결 방법

### 1. Eager Loading (즉시 로딩)

관련된 엔티티를 한 번의 쿼리로 함께 가져오는 방법입니다.

#### Prisma 예시

```typescript
const boardsWithReplies = await prisma.board.findMany({
  include: {
    replies: true
  }
});
```

#### TypeORM 예시

```typescript
const boardsWithReplies = await boardRepository.find({
  relations: ["replies"]
});
```

#### 실행되는 SQL

```sql
-- JOIN을 사용하여 한 번에 데이터를 가져옴
SELECT b.*, r.* FROM board b
LEFT JOIN reply r ON b.id = r.board_id
WHERE b.id IN (1, 2, 3, ..., 10);
```

### 2. Batch Loading (일괄 로딩)

여러 개체의 관련 데이터를 한 번에 가져오는 방법입니다.

```typescript
// 게시글 목록을 가져옴
const boards = await boardRepository.findAll();

// 모든 게시글 ID를 수집
const boardIds = boards.map(board => board.id);

// 한 번의 쿼리로 모든 댓글을 가져옴
const allReplies = await replyRepository.findByBoardIds(boardIds);

// 메모리에서 댓글을 해당 게시글에 매핑
for (const board of boards) {
  board.replies = allReplies.filter(reply => reply.boardId === board.id);
}
```

#### 실행되는 SQL

```sql
-- 게시글 목록 조회
SELECT * FROM board LIMIT 10;

-- 한 번의 쿼리로 모든 관련 댓글을 가져옴
SELECT * FROM reply WHERE board_id IN (1, 2, 3, ..., 10);
```

### 3. DataLoader 패턴

Facebook에서 개발한 DataLoader 패턴은 특히 GraphQL 환경에서 N+1 문제를 해결하는 데 효과적입니다. 동일한 요청 내에서 중복 쿼리를 방지하고 배치 처리를 지원합니다.

```typescript
import DataLoader from 'dataloader';

// 댓글 로더 생성
const replyLoader = new DataLoader(async (boardIds) => {
  const replies = await replyRepository.findByBoardIds(boardIds);
  
  // boardId별로 댓글 그룹화
  const replyMap = new Map();
  boardIds.forEach(id => replyMap.set(id, []));
  
  replies.forEach(reply => {
    if (replyMap.has(reply.boardId)) {
      replyMap.get(reply.boardId).push(reply);
    }
  });
  
  // 각 boardId에 대한 댓글 배열 반환
  return boardIds.map(id => replyMap.get(id) || []);
});

// 사용 예시
for (const board of boards) {
  board.replies = await replyLoader.load(board.id);
}
```

### 4. Query Builder를 사용한 최적화

복잡한 쿼리에 대해서는 쿼리 빌더를 사용하여 직접 SQL을 최적화할 수 있습니다.

#### Prisma 예시

```typescript
const result = await prisma.$queryRaw`
  SELECT 
    b.*, 
    JSON_AGG(r.*) AS replies
  FROM board b
  LEFT JOIN reply r ON b.id = r.board_id
  GROUP BY b.id
  LIMIT 10
`;
```

### 5. Lazy Loading과 캐싱 조합

특정 상황에서는 지연 로딩(Lazy Loading)과 적절한 캐싱을 조합하는 것이 더 효과적일 수 있습니다.

```typescript
// 캐시 레이어 (예: Redis, 인메모리 캐시 등)
const cacheManager = new CacheManager();

async function getBoardReplies(boardId) {
  // 캐시 확인
  const cachedReplies = await cacheManager.get(`board:${boardId}:replies`);
  if (cachedReplies) {
    return cachedReplies;
  }
  
  // 캐시에 없을 경우 DB 조회
  const replies = await replyRepository.findByBoardId(boardId);
  
  // 캐시에 저장
  await cacheManager.set(`board:${boardId}:replies`, replies, 3600); // 1시간 캐싱
  
  return replies;
}
```

## NestJS에서의 구현 예시

### 서비스 레이어에서 최적화

```typescript
@Injectable()
export class BoardService {
  constructor(
    private readonly boardRepository: BoardRepository,
    private readonly replyRepository: ReplyRepository,
  ) {}

  async getBoardsWithReplies() {
    // 게시글 목록 조회
    const boards = await this.boardRepository.findAll();
    
    // 게시글 ID 추출
    const boardIds = boards.map(board => board.id);
    
    // 한 번에 모든 댓글 조회
    const replies = await this.replyRepository.findByBoardIds(boardIds);
    
    // 댓글을 게시글별로 매핑
    const replyMap = replies.reduce((map, reply) => {
      if (!map[reply.boardId]) {
        map[reply.boardId] = [];
      }
      map[reply.boardId].push(reply);
      return map;
    }, {});
    
    // 게시글에 댓글 할당
    boards.forEach(board => {
      board.replies = replyMap[board.id] || [];
    });
    
    return boards;
  }
}
```

### Prisma를 사용한 최적화

```typescript
@Injectable()
export class BoardService {
  constructor(private readonly prisma: PrismaService) {}

  async getBoardsWithReplies() {
    return this.prisma.board.findMany({
      include: {
        replies: true,
        author: true, // 필요한 경우 다른 관계도 포함
      },
      where: {
        deletedAt: null,
      },
      orderBy: {
        createdAt: 'desc',
      },
    });
  }
}
```

## 성능 비교

|접근 방식|쿼리 수|장점|단점|
|---|---|---|---|
|N+1 패턴|N+1|구현이 간단함|성능이 매우 저하됨|
|Eager Loading|1|단일 쿼리로 모든 데이터 로드|불필요한 데이터까지 로드될 수 있음|
|Batch Loading|2|필요한 데이터만 로드|메모리에서 데이터 매핑 필요|
|DataLoader|최적화|중복 쿼리 방지, 배치 처리|설정이 복잡할 수 있음|
|Query Builder|1|고도로 최적화된 쿼리|SQL에 대한 깊은 이해 필요|
|캐싱 + 지연 로딩|다양함|자주 접근하는 데이터의 빠른 검색|캐시 일관성 관리 필요|

## 결론

N+1 문제는 데이터베이스 쿼리를 최적화하지 않을 때 발생하는 일반적인 성능 문제입니다. 적절한 로딩 전략(Eager Loading, Batch Loading), DataLoader 패턴, 쿼리 최적화 등을 통해 이 문제를 해결할 수 있습니다. 애플리케이션의 특성과 데이터 접근 패턴에 따라 가장 적합한 해결책을 선택하는 것이 중요합니다.

특히 NestJS와 Prisma 또는 TypeORM과 같은 현대적인 ORM을 사용할 때는 관계형 데이터를 로드하는 기능을 잘 활용하여 N+1 문제를 사전에 방지할 수 있습니다.