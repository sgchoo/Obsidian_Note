[[part2. 객체지향 프로그래밍 (Java)]]

# 디자인 패턴 개념 정리

## 디자인 패턴이란?

디자인 패턴은 소프트웨어 설계 과정에서 자주 발생하는 문제들에 대한 재사용 가능한 해결책입니다. 이는 코드의 유지보수성, 확장성, 가독성을 높이고 개발자 간의 의사소통을 원활하게 합니다. GoF(Gang of Four)라 불리는 4명의 저자가 "Design Patterns: Elements of Reusable Object-Oriented Software" 책에서 23가지 패턴을 정리하여 체계화했습니다.

디자인 패턴의 주요 이점:

- 검증된 개발 패러다임 재사용
- 개발자 간 의사소통 향상
- 소프트웨어 구조 개선
- 유지보수 용이성 증대
- 코드 재사용성 향상

## 생성 디자인 패턴(Creational Pattern)

### Abstract Factory Pattern

- **개념**: 구체적인 클래스를 지정하지 않고 관련성이 있거나 의존적인 객체들의 패밀리를 생성하기 위한 인터페이스 제공
- **용도**: 여러 제품군을 다룰 때 유용하며, 제품군 간의 일관성을 유지하는 데 도움이 됨
- **장점**: 구체적인 클래스에 의존하지 않고, 인터페이스에 의존하여 느슨한 결합 구현
- **예시**: 여러 운영체제용 UI 컴포넌트 생성(Windows, Mac, Linux용 버튼, 체크박스 등)

### Builder Pattern

- **개념**: 복잡한 객체의 생성 과정과 표현 방법을 분리하여 다양한 구성의 인스턴스를 만드는 패턴
- **용도**: 객체 생성 코드와 표현 코드를 분리하여 동일한 생성 과정으로 서로 다른 표현 결과를 만들 수 있음
- **장점**: 객체 생성 단계를 세분화하고, 객체 생성 과정을 더 세밀하게 제어할 수 있음
- **예시**: 복잡한 문서 객체, 복합 SQL 쿼리 생성, 복잡한 설정이 필요한 객체 생성

### Factory Method Pattern

- **개념**: 객체 생성 처리를 서브클래스로 분리해 처리하도록 캡슐화하는 패턴
- **용도**: 객체 생성 인터페이스를 정의하고, 인스턴스 생성은 서브클래스가 결정하도록 함
- **장점**: 객체 생성 코드와 사용 코드를 분리하여 결합도를 낮추고, 확장성을 높임
- **예시**: 문서 편집기에서 다양한 형식의 문서 생성, 로깅 프레임워크에서 다양한 로거 생성

### Prototype Pattern

- **개념**: 기존 객체를 복제하여 새로운 객체를 생성하는 패턴
- **용도**: 객체 생성 비용이 큰 경우, 기존 객체를 복제함으로써 효율성을 높임
- **장점**: 객체 초기화 비용을 줄이고, 클래스에 의존하지 않고 객체를 생성할 수 있음
- **예시**: 그래픽 에디터에서 복사-붙여넣기 기능, 게임에서 NPC 복제

### Singleton Pattern

- **개념**: 클래스의 인스턴스가 하나만 생성되도록 보장하고, 이에 대한 전역 접근점을 제공하는 패턴
- **용도**: 리소스 공유가 필요한 경우나 글로벌 상태 관리에 유용함
- **장점**: 메모리 낭비 방지, 전역 접근성 제공, 오직 한 개의 인스턴스 보장
- **예시**: 데이터베이스 연결 관리자, 로깅 인스턴스, 설정 관리자, 캐싱 등

## 구조 디자인 패턴(Structural Pattern)

구조 패턴은 클래스와 객체를 더 큰 구조로 조합하는 방법을 다루며, 구조를 유연하고 효율적으로 유지하면서 기능을 확장할 수 있게 합니다.

### Adapter Pattern

- **개념**: 호환되지 않는 인터페이스를 함께 작동할 수 있도록 변환해주는 패턴
- **용도**: 기존 클래스를 수정하지 않고 클라이언트가 기대하는 인터페이스로 변환
- **장점**: 기존 코드 재사용, 클래스 간의 결합도 감소, 인터페이스 통일성 제공
- **예시**: 레거시 시스템과 새 시스템 연동, 외부 라이브러리 통합, 다양한 데이터 형식 변환

### Aggregate Pattern

- **개념**: 관련 객체들의 집합을 추상화하여 처리하는 패턴
- **용도**: 복잡한 데이터 구조를 단순화하고 효율적으로 조작할 수 있도록 함
- **장점**: 데이터 처리 로직 캡슐화, 복잡한 데이터 구조의 단순한 인터페이스 제공
- **예시**: 대용량 데이터 처리, 이벤트 스트림 처리, 복잡한 데이터 집계 작업

### Bridge Pattern

- **개념**: 추상화와 구현을 분리하여 두 개를 독립적으로 확장할 수 있게 하는 패턴
- **용도**: 구현부에서 추상층을 분리하여 각자 독립적으로 변형이 가능하도록 함
- **장점**: 추상화와 구현의 결합도 감소, 확장성 향상, 클라이언트 코드에 영향 없이 구현 변경 가능
- **예시**: 다양한 플랫폼에서 작동하는 그래픽 API, 다양한 데이터베이스 드라이버 지원 시스템

### Composite Pattern

- **개념**: 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴
- **용도**: 개별 객체와 복합 객체를 동일하게 다룰 수 있게 함
- **장점**: 복잡한 트리 구조를 쉽게 구성, 새로운 구성 요소 추가 용이, 클라이언트 코드 단순화
- **예시**: 파일 시스템 구현, GUI 컴포넌트 구성, 조직도 표현

### Decorator Pattern

- **개념**: 객체에 동적으로 책임을 추가할 수 있게 하는 패턴
- **용도**: 상속을 사용하지 않고 기능을 확장할 수 있음
- **장점**: 런타임에 객체 기능 확장, 단일 책임 원칙 준수, 상속 대신 합성 사용으로 유연성 증가
- **예시**: 텍스트 포맷팅 기능, 입출력 스트림 필터, UI 컴포넌트 기능 확장

### Facade Pattern

- **개념**: 서브시스템의 인터페이스 집합에 통합된 하나의 인터페이스를 제공하는 패턴
- **용도**: 복잡한 서브시스템을 간단한 인터페이스로 접근할 수 있게 함
- **장점**: 서브시스템 사용 단순화, 클라이언트와 서브시스템 간의 결합도 감소, 복잡성 은닉
- **예시**: 복잡한 라이브러리 래퍼, 통합 API 인터페이스, 복잡한 시스템의 간편한 진입점

### Pipes and Filters

- **개념**: 데이터 스트림 처리 작업을 일련의 처리 단계(필터)로 나누고 이를 파이프로 연결하는 패턴
- **용도**: 각 단계는 독립적으로 실행되며, 복잡한 처리 과정을 모듈화함
- **장점**: 재사용성 증가, 시스템 확장 용이, 처리 단계의 조합 가능, 병렬 처리 가능성
- **예시**: ETL 프로세스, 텍스트 처리 파이프라인, 미디어 인코딩 시스템

## 행위 디자인 패턴(Behavioral Pattern)

행위 패턴은 객체 간의 알고리즘과 책임 할당에 관한 패턴으로, 객체 간의 통신 방법과 책임 분배 방식을 다룹니다.

### Chain of Responsibility

- **개념**: 요청을 처리할 수 있는 객체가 여러 개일 때, 이를 연쇄적으로 묶어 처리하는 패턴
- **용도**: 요청의 발신자와 수신자를 분리하여 유연성을 높임
- **장점**: 결합도 감소, 책임 분산, 요청 처리 순서 변경 용이
- **예시**: 이벤트 버블링, 예외 처리 체인, 필터 체인(미들웨어), 승인 처리 워크플로우

### Command

- **개념**: 요청을 객체로 캡슐화하여 서로 다른 요청에 대한 매개변수화, 요청 큐잉, 요청 로깅 등을 지원하는 패턴
- **용도**: 요청을 발신자로부터 수신자로 전달하는 과정을 객체화함
- **장점**: 작업 실행 시점 유연성, 실행 취소/재실행 기능 지원, 명령 조합 가능
- **예시**: GUI 버튼 액션, 트랜잭션 처리, 매크로 기능, 작업 스케줄링

### Interpreter

- **개념**: 언어의 문법이나 표현을 평가하는 방법을 정의하는 패턴
- **용도**: 특정 언어로 작성된 프로그램을 해석하는 클래스들을 구현함
- **장점**: 문법 규칙 확장 용이, 복잡한 표현식 해석 체계화, 언어 문법 표현 가능
- **예시**: SQL 파서, 정규 표현식 엔진, 수학 표현식 계산기, 스크립트 인터프리터

### Iterator

- **개념**: 컬렉션의 내부 표현을 노출하지 않고 요소에 순차적으로 접근하는 방법을 제공하는 패턴
- **용도**: 다양한 컬렉션 구조에 대해 일관된 접근 방식을 제공함
- **장점**: 컬렉션 내부 구조 은닉, 일관된 탐색 인터페이스 제공, 다양한 순회 알고리즘 지원
- **예시**: 다양한 컬렉션(리스트, 트리, 그래프 등) 순회, for-each 루프 구현, 페이지네이션

### Mediator

- **개념**: 객체 간의 복잡한 상호작용을 캡슐화하는 중재자 객체를 통해 결합도를 낮추는 패턴
- **용도**: 객체 간 직접 통신 대신 중재자를 통해 간접적으로 통신하게 함
- **장점**: n:n 관계를 1:n 관계로 단순화, 객체 간 결합도 감소, 상호작용 로직 중앙화
- **예시**: 채팅룸, 항공 교통 관제 시스템, GUI 컴포넌트 간 통신

### Observer

- **개념**: 객체 사이에 일대다 의존 관계를 정의하고, 객체 상태 변경 시 의존성 있는 객체들에게 자동 통지하는 패턴
- **용도**: 상태 변화를 감지하고 다른 객체에 알리는 발행-구독 모델 구현
- **장점**: 느슨한 결합 구현, 상태 변경 시 일관된 업데이트 보장, 변경 사항의 브로드캐스팅
- **예시**: 이벤트 핸들링 시스템, GUI 업데이트, MVC 패턴의 모델-뷰 관계, 데이터 바인딩

## 디자인 패턴 사용 시 고려사항

### 장점

- 검증된 솔루션으로 개발 시간 단축
- 코드 품질 향상 및 유지보수성 개선
- 개발자 간 의사소통 향상
- 확장성 있는 시스템 설계 가능

### 단점

- 과도한 패턴 적용은 복잡성 증가 가능
- 불필요한 곳에 패턴 적용 시 오버엔지니어링 발생
- 초기 학습 곡선이 존재함

### 효과적인 패턴 사용법

- 문제를 먼저 이해하고 적절한 패턴 선택
- 패턴을 맹목적으로 따르지 말고 상황에 맞게 조정
- 여러 패턴의 조합으로 복잡한 문제 해결
- 코드 단순화가 목표임을 잊지 말 것